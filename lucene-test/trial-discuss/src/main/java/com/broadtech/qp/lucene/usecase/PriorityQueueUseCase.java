package com.broadtech.qp.lucene.usecase;

import org.apache.lucene.util.PriorityQueue;

import java.util.Iterator;
import java.util.Random;

/**
 * Created by jeifi on 2017/8/2.
 * 测试{@link org.apache.lucene.util.PriorityQueue}用法<br>
 * <p>
 * the least element can always be found in constant time.
 * 最小元素总是在常数时间内返回 接口: top()
 * Put()'s and pop()'s require log(size) time but the remove() cost implemented here is linear.
 * (put() pop() log(size)时间开销，remove()线性时间开销)
 * <p>
 * {@link org.apache.lucene.search.BooleanScorer.HeadPriorityQueue}
 * {@link org.apache.lucene.search.BooleanScorer.TailPriorityQueue}
 */
public class PriorityQueueUseCase {

    public static class Priority extends PriorityQueue<Integer> {

        public Priority(int maxSize) {
            super(maxSize);
        }

        @Override
        protected boolean lessThan(Integer a, Integer b) {
            return a < b;
        }

        @Override
        protected Integer getSentinelObject() {
            return -1;
        }

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder("[");
            Iterator<Integer> itr = iterator();
            while (itr.hasNext()) {
                builder.append(itr.next()).append(",");
            }
            builder.append("]");
            return builder.toString();
        }
    }

    public static void main(String[] args) {
        test();
//        test2();
    }

    /**
     * 输出：始终保持第1位存储最小值
     * <p>
     * original	[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,]
     * 0	0	[1,3,2,7,4,5,6,15,8,9,10,11,12,13,14,29,16,17,18,19,20,21,22,23,24,25,26,27,28,]
     * 1	1	[2,3,5,7,4,11,6,15,8,9,10,23,12,13,14,29,16,17,18,19,20,21,22,28,24,25,26,27,]
     * 2	2	[3,4,5,7,9,11,6,15,8,19,10,23,12,13,14,29,16,17,18,27,20,21,22,28,24,25,26,]
     * 3	3	[4,7,5,8,9,11,6,15,17,19,10,23,12,13,14,29,16,26,18,27,20,21,22,28,24,25,]
     * 4	4	[5,7,6,8,9,11,13,15,17,19,10,23,12,25,14,29,16,26,18,27,20,21,22,28,24,]
     * 5	5	[6,7,11,8,9,12,13,15,17,19,10,23,24,25,14,29,16,26,18,27,20,21,22,28,]
     * 6	6	[7,8,11,15,9,12,13,16,17,19,10,23,24,25,14,29,28,26,18,27,20,21,22,]
     * 7	7	[8,9,11,15,10,12,13,16,17,19,21,23,24,25,14,29,28,26,18,27,20,22,]
     * 8	8	[9,10,11,15,19,12,13,16,17,20,21,23,24,25,14,29,28,26,18,27,22,]
     * 9	9	[10,15,11,16,19,12,13,22,17,20,21,23,24,25,14,29,28,26,18,27,]
     * 10	10	[11,15,12,16,19,23,13,22,17,20,21,27,24,25,14,29,28,26,18,]
     * 11	11	[12,15,13,16,19,23,14,22,17,20,21,27,24,25,18,29,28,26,]
     * 12	12	[13,15,14,16,19,23,18,22,17,20,21,27,24,25,26,29,28,]
     * 13	13	[14,15,18,16,19,23,25,22,17,20,21,27,24,28,26,29,]
     * 14	14	[15,16,18,17,19,23,25,22,29,20,21,27,24,28,26,]
     * 15	15	[16,17,18,22,19,23,25,26,29,20,21,27,24,28,]
     * 16	16	[17,19,18,22,20,23,25,26,29,28,21,27,24,]
     * 17	17	[18,19,23,22,20,24,25,26,29,28,21,27,]
     * 18	18	[19,20,23,22,21,24,25,26,29,28,27,]
     * 19	19	[20,21,23,22,27,24,25,26,29,28,]
     * 20	20	[21,22,23,26,27,24,25,28,29,]
     * 21	21	[22,26,23,28,27,24,25,29,]
     * 22	22	[23,26,24,28,27,29,25,]
     * 23	23	[24,26,25,28,27,29,]
     * 24	24	[25,26,29,28,27,]
     * 25	25	[26,27,29,28,]
     * 26	26	[27,28,29,]
     * 27	27	[28,29,]
     * 28	28	[29,]
     * 29	29	[]
     * </p>
     */
    private static void test() {
        Priority p = new Priority(30);
        for (int i = 0; i < 30; i++) {
            p.insertWithOverflow(i);
        }
        System.out.println("插入顺序数据");
        System.out.println("original\t" + p.toString());
        for (int i = 0; i < 30; i++) {
            System.out.println(i + "\t" + p.pop() + "\t" + p.toString());
        }
    }

    /**
     * 随机数据
     * 从结果可以看到最小的数据在第一位
     * <p>
     * original	[-24,-23,-23,-19,-22,-3,-16,-5,-16,0,-21,-1,-1,-2,-12,21,-4,28,14,8,2,19,-17,28,16,8,8,17,4,2,]
     * 0	-24	[-23,-22,-23,-19,-21,-3,-16,-5,-16,0,-17,-1,-1,-2,-12,21,-4,28,14,8,2,19,2,28,16,8,8,17,4,]
     * 1	-23	[-23,-22,-16,-19,-21,-3,-12,-5,-16,0,-17,-1,-1,-2,4,21,-4,28,14,8,2,19,2,28,16,8,8,17,]
     * 2	-23	[-22,-21,-16,-19,-17,-3,-12,-5,-16,0,2,-1,-1,-2,4,21,-4,28,14,8,2,19,17,28,16,8,8,]
     * 3	-22	[-21,-19,-16,-16,-17,-3,-12,-5,8,0,2,-1,-1,-2,4,21,-4,28,14,8,2,19,17,28,16,8,]
     * 4	-21	[-19,-17,-16,-16,0,-3,-12,-5,8,2,2,-1,-1,-2,4,21,-4,28,14,8,8,19,17,28,16,]
     * 5	-19	[-17,-16,-16,-5,0,-3,-12,-4,8,2,2,-1,-1,-2,4,21,16,28,14,8,8,19,17,28,]
     * 6	-17	[-16,-5,-16,-4,0,-3,-12,16,8,2,2,-1,-1,-2,4,21,28,28,14,8,8,19,17,]
     * 7	-16	[-16,-5,-12,-4,0,-3,-2,16,8,2,2,-1,-1,17,4,21,28,28,14,8,8,19,]
     * 8	-16	[-12,-5,-3,-4,0,-1,-2,16,8,2,2,19,-1,17,4,21,28,28,14,8,8,]
     * 9	-12	[-5,-4,-3,8,0,-1,-2,16,8,2,2,19,-1,17,4,21,28,28,14,8,]
     * 10	-5	[-4,0,-3,8,2,-1,-2,16,8,8,2,19,-1,17,4,21,28,28,14,]
     * 11	-4	[-3,0,-2,8,2,-1,4,16,8,8,2,19,-1,17,14,21,28,28,]
     * 12	-3	[-2,0,-1,8,2,-1,4,16,8,8,2,19,28,17,14,21,28,]
     * 13	-2	[-1,0,-1,8,2,19,4,16,8,8,2,28,28,17,14,21,]
     * 14	-1	[-1,0,4,8,2,19,14,16,8,8,2,28,28,17,21,]
     * 15	-1	[0,2,4,8,2,19,14,16,8,8,21,28,28,17,]
     * 16	0	[2,2,4,8,8,19,14,16,8,17,21,28,28,]
     * 17	2	[2,8,4,8,8,19,14,16,28,17,21,28,]
     * 18	2	[4,8,14,8,8,19,28,16,28,17,21,]
     * 19	4	[8,8,14,16,8,19,28,21,28,17,]
     * 20	8	[8,8,14,16,17,19,28,21,28,]
     * 21	8	[8,16,14,21,17,19,28,28,]
     * 22	8	[14,16,19,21,17,28,28,]
     * 23	14	[16,17,19,21,28,28,]
     * 24	16	[17,21,19,28,28,]
     * 25	17	[19,21,28,28,]
     * 26	19	[21,28,28,]
     * 27	21	[28,28,]
     * 28	28	[28,]
     * 29	28	[]
     * </p>
     */
    private static void test2() {
        Priority p = new Priority(30);
        Random random = new Random(1000);
        for (int i = 0; i < 30; i++) {
            p.insertWithOverflow(random.nextInt() % 30);
        }
        System.out.println("插入随机数据");
        System.out.println("original\t" + p.toString());
        for (int i = 0; i < 30; i++) {
            System.out.println(i + "\t" + p.pop() + "\t" + p.toString());
        }
    }
}
